#include <cassert>
#include <chrono>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <thread>
#include <vector>

using namespace std::literals::chrono_literals;

// ==== Generated by protobufs

enum class ErrorCode { success, failure };

struct ID {
  int which = 0;
  std::string user;  // 1
  std::string space; // 1
};

struct Result {
  int32_t error_code = 0;
};

struct User {
  std::string name;
};

struct UserAuth {
  std::string password;
};

struct UserID {
  std::string username;
};

struct UserSession {
  std::string token;
};

struct UserRequest {
  int which = 0;
  UserAuth auth; // 1
  UserID get;    // 2
  UserID ping;   // 3
  ID target;
};

struct UserResponse {
  int which = 0;
  UserSession auth; // 1
  User get;         // 2
  Result ping;      // 3
};

struct Space {
  std::string name;
};

struct SpaceRequest {
  int which = 0;
  UserID join; // 1
  ID target;
};

struct SpaceResponse {
  int which = 0;
  Result join; // 1
};

struct RequestHeader {
  // todo
};

struct Request {
  RequestHeader header;
  int which = 0;
  UserRequest user;   // 1
  SpaceRequest space; // 2
};

struct ResponseHeader {
  // todo
};

struct Response {
  ResponseHeader header;
  int which = 0;
  UserResponse user;   // 1
  SpaceResponse space; // 2
  ErrorCode error;
};

struct Packet {
  std::vector<Request> requests;
  std::vector<Response> responses;
};

// ==== Foundation

struct Actor;
struct Continuation;
struct FiberState;
struct Fiber;

// TODO: strand mode
struct FiberState {
  enum class Status { initial, succeed, fail };

  FiberState(std::weak_ptr<Actor> actor) : host{actor} {}

  std::deque<std::function<void(Continuation)>> work_list;
  mutable size_t next_work_id = 0;

  std::function<void(Continuation)> on_success;
  std::function<void(Continuation)> on_failure;

  mutable std::weak_ptr<Actor> host;
  mutable std::atomic<bool> dispose{false};
  mutable Status status = Status::initial;
  bool is_strand = false;
};

// TODO: single parameter passing
struct Continuation {
  Continuation(std::shared_ptr<FiberState> state) : state{state} {}
  // TODO: behavior if next/quit are not called when all continuations exit

  void run_once();
  void run_once_here();

  void terminate(FiberState::Status status);
  void terminate_here(FiberState::Status status);

  void next() { run_once(); }
  void quit() { terminate(FiberState::Status::succeed); }
  void fail() { terminate(FiberState::Status::fail); }

  std::shared_ptr<const FiberState> state;
};

struct Fiber {
  Fiber() = default;
  Fiber(std::shared_ptr<FiberState> state) : state{state} {}

  bool is_ready() const { return static_cast<bool>(state); }

  template <typename Functional> Fiber &then(Functional &&work) {
    state->work_list.emplace_back(std::forward<Functional>(work));
    return *this;
  }

  Continuation start() {
    Continuation initial{state};
    state.reset(); // release ownership
    return initial;
  }

  std::shared_ptr<FiberState> state;
};

struct Actor : public std::enable_shared_from_this<Actor> {
  Actor(std::string uuid) {
    thread = std::thread{[this] {
      for (;;) {
        run_once();
      }
    }};
  }

  Actor() { thread.detach(); }

  template <typename Functional> void post(Functional &&work) {
    std::lock_guard<decltype(mutex)> _{mutex};
    work_list.emplace_back(std::forward<Functional>(work));
  }

  void run_once() {
    std::lock_guard<decltype(mutex)> _{mutex};
    if (work_list.size()) {
      work_list.front()();
      work_list.pop_front();
    }
  }

  Fiber create_fiber() {
    auto state = std::make_shared<FiberState>(shared_from_this());
    fibers.push_back(state);
    return Fiber{state};
  }

  std::vector<std::shared_ptr<FiberState>> fibers;
  std::deque<std::function<void()>> work_list;
  std::thread thread;
  std::mutex mutex;
};

void Continuation::run_once() {
  if (auto host = state->host.lock()) {
    host->post([continuation = *this]() mutable {
      continuation.run_once_here();
    });
  }
}

void Continuation::run_once_here() {
  auto next = state->next_work_id++;
  if (next < state->work_list.size()) {
    state->work_list[next](*this);
  } else {
    state->dispose = true;
  }
}

void Continuation::terminate(FiberState::Status status) {
  if (auto host = state->host.lock()) {
    host->post([ continuation = *this, status ]() mutable {
      continuation.terminate_here(status);
    });
  }
}

void Continuation::terminate_here(FiberState::Status status) {
  switch (status) {
  case FiberState::Status::initial:
  case FiberState::Status::succeed:
    state->on_success(*this);
    break;
  case FiberState::Status::fail:
    state->on_failure(*this);
    break;
  };

  if (auto host = state->host.lock()) {
    host->fibers.erase(
        std::remove(begin(host->fibers), end(host->fibers), state),
        end(host->fibers));
  }
}

struct ActorGroup {};

struct ActorPool {
  template <typename Type>
  std::shared_ptr<Actor> get_or_create_actor(ActorGroup &group,
                                             std::string id) {
    return std::static_pointer_cast<Actor>(
        actors.emplace(id, std::make_shared<Type>(id)).first->second);
  }

  std::map<std::string, std::shared_ptr<Actor>> actors;
};

class RpcBase;
bool is_server_only_rpc(const RpcBase *rpc);

class RpcBase {
public:
  virtual void execute() = 0;
  virtual void set_on_complete(std::function<void(ErrorCode)>) = 0;

  bool is_server_only() const {
    return is_server_only_rpc(this);
  };
};

class RpcHandlerBase {
public:
  virtual Request &request() = 0;
  virtual Response &response() = 0;
  virtual RpcBase &rpc() = 0;

  virtual const Request &request() const = 0;
  virtual const Response &response() const = 0;
  virtual const RpcBase &rpc() const = 0;
};

struct RpcRegistry {
  size_t adopt(std::unique_ptr<RpcHandlerBase> &&rpc) {
    std::lock_guard<decltype(mutex)> _{mutex};
    rpcs[tag] = std::move(rpc);
    return tag++;
  }

  std::unique_ptr<RpcHandlerBase> release(size_t tag) {
    std::lock_guard<decltype(mutex)> _{mutex};
    return std::move(rpcs[tag]);
  }

  RpcHandlerBase *at(size_t tag) {
    std::lock_guard<decltype(mutex)> _{mutex};
    return rpcs[tag].get();
  }

  std::mutex mutex;
  std::map<size_t, std::unique_ptr<RpcHandlerBase>> rpcs;
  size_t tag = 1;
};

struct Service : public Actor {
  using Actor::Actor;

  RpcRegistry rpcs;
};

struct Mesh {
  struct Destination {};

  struct Domain {
    struct Local {
      ActorGroup *group = nullptr;
      bool singleton = false;
    };

    struct Remote {
      Destination destination;
    };

    // NOTE: C++17 has std::variant
    enum class Type { local, remote };

    Type type;
    Local local;
    Remote remote;
  };

  Domain should_forward(std::string id) {
    static ActorGroup global;
    Domain result;
    result.type = Domain::Type::local;
    result.local.group = &global;
    return result;
  }
};

template <typename Type> class Channel {
public:
  size_t size() const {
    std::lock_guard<decltype(mtx_)> _{mtx_};
    return queue_.size();
  }

  bool empty() const {
    std::lock_guard<decltype(mtx_)> _{mtx_};
    return queue_.empty();
  }

  void push(Type value) {
    std::lock_guard<decltype(mtx_)> _{mtx_};
    queue_.push_back(value);
  }

  bool pop(Type &value) {
    std::lock_guard<decltype(mtx_)> _{mtx_};
    bool success = !queue_.empty();
    if (success) {
      value = queue_.front();
      queue_.pop_front();
    }
    return success;
  }

private:
  mutable std::mutex mtx_;
  std::deque<Type> queue_;
};

Mesh::Domain resolve_rpc(Mesh &mesh, Request &request);
RpcHandlerBase *reify_rpc(ActorPool &pool, ActorGroup &group, Request &request);

struct Dispatcher {
  void connect(Channel<Packet> &to, Channel<Packet> &from) {
    to_device = &to;
    from_device = &from;
  }

  void handle(Packet packet) {
    for (auto &&request : packet.requests) {
      auto result = resolve_rpc(mesh, request);
      switch (result.type) {
      case Mesh::Domain::Type::local: {
        auto handler = reify_rpc(actors, *result.local.group, request);

        handler->rpc().set_on_complete([this, handler](auto error) {
          auto &&response = handler->response();
          response.error = error;

          Packet packet;
          packet.responses.push_back(response);
          to_device->push(packet);
        });
        handler->rpc().execute();

      } break;
      case Mesh::Domain::Type::remote:
        break;
      }
    }
  }

  Channel<Packet> *to_device;
  Channel<Packet> *from_device;
  ActorPool actors;
  Mesh mesh;
};

struct Device {
  void send(const Packet &packet) { outgoing.push(packet); };
  bool recv(Packet &packet) { return incoming.pop(packet); };

  Channel<Packet> &outgoing;
  Channel<Packet> &incoming;
};

struct Server {
  void send(const Packet &packet) { outgoing.push(packet); };
  bool recv(Packet &packet) { return incoming.pop(packet); };

  Channel<Packet> &outgoing;
  Channel<Packet> &incoming;
};

// ==== RPC user implementation

struct UserService : public Service,
                     public std::enable_shared_from_this<UserService> {
  using Service::Service;

  UserSession Auth(UserAuth &request) {
    UserSession response;
    response.token = request.password == "sekret" ? "guhjob" : "buhboo";
    return response;
  }

  User Get(UserID &request) { return {}; }

  Result Ping(UserID &request) { return {}; }
};

struct SpaceService : public Service,
                      public std::enable_shared_from_this<SpaceService> {
  using Service::Service;

  Result Join(UserID &request) { return {}; }
};

// ==== RPC infrastructure
// TODO to put the per-RPC options (traits?)

template <typename Service, typename Method, typename Input, typename Output>
class Rpc : public RpcBase {
public:
  Rpc(std::shared_ptr<Service> service, Method method, Input &input,
      Output &output)
      : m_request{input}, m_response{output}, m_method{method},
        m_service{service} {}

  Request &request() { return m_request; }
  Response &response() { return m_response; }

  const Request &request() const { return m_request; }
  const Response &response() const { return m_response; }

  void execute() override {
    if (auto service = m_service.lock()) {
      service->post([ this, ptr = service.get() ] {
        m_response = (*ptr.*m_method)(m_request);
        // TODO: fire+forget rpcs are always successful
        // fibered rpcs may return failure cases
        if (m_complete_handler) {
          m_complete_handler(ErrorCode::success);
        }
      });
    }
  }

  void set_on_complete(std::function<void(ErrorCode)> handler) override {
    m_complete_handler = handler;
  }

private:
  Input &m_request;
  Output &m_response;
  Method m_method = nullptr;
  std::weak_ptr<Service> m_service;
  std::function<void(ErrorCode)> m_complete_handler;
};

template <typename T> class RpcHandler {};

template <typename Service, typename Input, typename Output>
class RpcHandler<Output (Service::*)(Input &)> : public RpcHandlerBase {
public:
  using RpcType = Rpc<Service, Output (Service::*)(Input &), Input, Output>;

  RpcHandler(Request &request) : m_request{request} {}

  void arm(std::unique_ptr<RpcType> &&rpc) { m_rpc = std::move(rpc); }

  Request &request() override { return m_request; }
  Response &response() override { return m_response; }
  RpcBase &rpc() override { return *m_rpc; }

  const Request &request() const override { return m_request; }
  const Response &response() const override { return m_response; }
  const RpcBase &rpc() const override { return *m_rpc; }

private:
  Request m_request;
  Response m_response;

  std::unique_ptr<RpcType> m_rpc;
};

// === Generated by RPC compiler

Mesh::Domain resolve_rpc(Mesh &mesh, Request &request) {
  switch (request.which) {
  case 1: // user request
    return mesh.should_forward(request.user.target.user);
  case 2: // space request
    return mesh.should_forward(request.space.target.space);
  }
  return {};
}

RpcHandlerBase *reify_rpc(ActorPool &pool, ActorGroup &group,
                          Request &request) {
  // NOTE(rcm): in C++17 types can be deduced from arguments
  switch (request.which) {
  case 1: // user request
  {
    auto uuid = request.user.target.user;
    auto service = pool.get_or_create_actor<UserService>(group, uuid);
    auto user = std::static_pointer_cast<UserService>(service);

    switch (request.user.which) {
    case 1: // auth
    {
      using HandlerType = RpcHandler<decltype(&UserService::Auth)>;
      using RpcType = typename HandlerType::RpcType;

      auto handler = std::make_unique<HandlerType>(request);
      auto ptr = handler.get();

      ptr->response().which = 1;
      ptr->response().user.which = 1;

      handler->arm(std::make_unique<RpcType>(user, &UserService::Auth,
                                             ptr->request().user.auth,
                                             ptr->response().user.auth));

      user->rpcs.adopt(std::move(handler));

      return ptr;
    }
    case 2: // get
    {
      using HandlerType = RpcHandler<decltype(&UserService::Get)>;
      using RpcType = typename HandlerType::RpcType;

      auto handler = std::make_unique<HandlerType>(request);
      auto ptr = handler.get();

      ptr->response().which = 1;
      ptr->response().user.which = 2;

      handler->arm(std::make_unique<RpcType>(user, &UserService::Get,
                                             ptr->request().user.get,
                                             ptr->response().user.get));

      user->rpcs.adopt(std::move(handler));

      return ptr;
    }
    case 3: // ping
    {
      using HandlerType = RpcHandler<decltype(&UserService::Ping)>;
      using RpcType = typename HandlerType::RpcType;

      auto handler = std::make_unique<HandlerType>(request);
      auto ptr = handler.get();

      ptr->response().which = 1;
      ptr->response().user.which = 3;

      handler->arm(std::make_unique<RpcType>(user, &UserService::Ping,
                                             ptr->request().user.ping,
                                             ptr->response().user.ping));

      user->rpcs.adopt(std::move(handler));

      return ptr;
    }
    }
  } break;
  case 2: // space request
  {
    auto uuid = request.space.target.space;
    auto service = pool.get_or_create_actor<SpaceService>(group, uuid);
    auto space = std::static_pointer_cast<SpaceService>(service);

    switch (request.space.which) {
    case 1: // join
    {
      using HandlerType = RpcHandler<decltype(&SpaceService::Join)>;
      using RpcType = typename HandlerType::RpcType;

      auto handler = std::make_unique<HandlerType>(request);
      auto ptr = handler.get();

      ptr->response().which = 2;
      ptr->response().space.which = 1;

      handler->arm(std::make_unique<RpcType>(space, &SpaceService::Join,
                                             ptr->request().space.join,
                                             ptr->response().space.join));

      space->rpcs.adopt(std::move(handler));

      return ptr;
    }
    }
  } break;
  }
  return {};
}

bool is_server_only_rpc(const RpcBase *rpc) {
  constexpr auto&& user_auth = typeid(RpcHandler<decltype(&UserService::Auth)>::RpcType);
  constexpr auto&& user_get = typeid(RpcHandler<decltype(&UserService::Get)>::RpcType);
  constexpr auto&& user_ping = typeid(RpcHandler<decltype(&UserService::Ping)>::RpcType);
  constexpr auto&& space_join = typeid(RpcHandler<decltype(&SpaceService::Join)>::RpcType);

  auto&& rpc_type = typeid(*rpc);

  // optimizer should generate a jump table and
  // be equivalent to switching on manual typeid
  if (rpc_type == user_auth) {
      return false;
  } else if (rpc_type == user_get) {
      return false;
  } else if (rpc_type == user_ping) {
      return false;
  } else if (rpc_type == space_join) {
      return false;
  }
  return false;
}

// ==== Run

int main() {
  Channel<Packet> from_device;
  Channel<Packet> from_server;

  std::thread server{[&] {
    Server server{from_server, from_device};
    Dispatcher dispatcher;
    dispatcher.connect(from_server, from_device);

    Packet packet;
    for (;;) {
      if (server.recv(packet)) {
        dispatcher.handle(packet);
      }
      std::this_thread::sleep_for(100ms);
    }
  }};

  std::thread device{[&] {
    Device device{from_device, from_server};

    Request request;
    request.which = 1;
    request.user.which = 1;
    request.user.auth.password = "sekret";
    request.user.target.user = "bob";

    Packet packet;
    packet.requests.push_back(request);
    device.send(packet);

    for (;;) {
      if (device.recv(packet)) {
        auto &response = packet.responses.back();
        if (response.which == 1 && response.user.which == 1 &&
            response.user.auth.token == "guhjob") {
          std::cout << "device authenticated" << std::endl;
        }
      }
      std::this_thread::sleep_for(100ms);
    }
  }};

  server.join();
  device.join();
}

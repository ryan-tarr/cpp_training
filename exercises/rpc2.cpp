#include <cassert>
#include <chrono>
#include <deque>
#include <iostream>
#include <map>
#include <thread>
#include <vector>

using namespace std::literals::chrono_literals;

// ==== Generated by protobufs

struct ID {
  int which = 0;
  std::string user;  // 1
  std::string space; // 1
};

struct Result {
  int32_t error_code = 0;
};

struct User {
  std::string name;
};

struct UserAuth {
  std::string password;
};

struct UserID {
  std::string username;
};

struct UserSession {
  std::string token;
};

struct UserRequest {
  int which = 0;
  UserAuth auth; // 1
  UserID get;    // 2
  UserID ping;   // 3
  ID target;
};

struct UserResponse {
  int which = 0;
  UserSession auth; // 1
  User get;         // 2
  Result ping;      // 3
};

struct Space {
  std::string name;
};

struct SpaceRequest {
  int which = 0;
  UserID join; // 1
  ID target;
};

struct SpaceResponse {
  int which = 0;
  Result join; // 1
};

struct RequestHeader {
  // todo
};

struct Request {
  RequestHeader header;
  int which = 0;
  UserRequest user;   // 1
  SpaceRequest space; // 2
};

struct ResponseHeader {
  // todo
};

struct Response {
  ResponseHeader header;
  int which = 0;
  UserResponse user;   // 1
  SpaceResponse space; // 2
};

struct Packet {
  std::vector<Request> requests;
  std::vector<Response> responses;
};

// ==== Foundation

struct Actor {
  Actor(std::string uuid) {
    thread = std::thread{[this] {
      for (;;) {
        run_once();
      }
    }};
  }

  Actor() { thread.detach(); }

  template <typename Functional> void post(Functional &&work) {
    std::lock_guard<decltype(mutex)> _{mutex};
    work_list.emplace_back(std::forward<Functional>(work));
  }

  void run_once() {
    std::lock_guard<decltype(mutex)> _{mutex};
    if (work_list.size()) {
      work_list.front()();
      work_list.pop_front();
    }
  }

  std::deque<std::function<void()>> work_list;
  std::thread thread;
  std::mutex mutex;
};

struct ActorPool {
  template <typename Type>
  std::shared_ptr<Actor> get_or_create_actor(std::string id) {
    return std::static_pointer_cast<Actor>(
        actors.emplace(id, std::make_shared<Type>(id)).first->second);
  }

  std::map<std::string, std::shared_ptr<Actor>> actors;
};

struct Service : public Actor {
  using Actor::Actor;
};

class RpcBase {
public:
  virtual void execute() {}
};

RpcBase reify_rpc(ActorPool &pool, Request &request);

struct Dispatcher {
  void handle(Packet packet) {
    for (auto &&request : packet.requests) {
      auto rpc = reify_rpc(actors, request);

      rpc.execute();
    }
  }

  ActorPool actors;
};

template <typename Type> class Channel {
public:
  size_t size() const {
    std::lock_guard<decltype(mtx_)> _{mtx_};
    return queue_.size();
  }

  bool empty() const {
    std::lock_guard<decltype(mtx_)> _{mtx_};
    return queue_.empty();
  }

  void push(Type value) {
    std::lock_guard<decltype(mtx_)> _{mtx_};
    queue_.push_back(value);
  }

  bool pop(Type &value) {
    std::lock_guard<decltype(mtx_)> _{mtx_};
    bool success = !queue_.empty();
    if (success) {
      value = queue_.front();
      queue_.pop_front();
    }
    return success;
  }

private:
  mutable std::mutex mtx_;
  std::deque<Type> queue_;
};

struct Device {
  void send(const Packet &packet) { outgoing.push(packet); };
  bool recv(Packet &packet) { return incoming.pop(packet); };

  Channel<Packet> &outgoing;
  Channel<Packet> &incoming;
};

struct Server {
  void send(const Packet &packet) { outgoing.push(packet); };
  bool recv(Packet &packet) { return incoming.pop(packet); };

  Channel<Packet> &outgoing;
  Channel<Packet> &incoming;
};

// ==== RPC user implementation

struct UserService : public Service,
                     public std::enable_shared_from_this<UserService> {
  using Service::Service;

  UserSession Auth(UserAuth &request) {
    UserSession response;
    response.token = request.password == "sekret" ? "guhjob" : "buhboo";
    return response;
  }

  User Get(UserID &request) { return {}; }

  Result Ping(UserID &request) { return {}; }
};

struct SpaceService : public Service,
                      public std::enable_shared_from_this<SpaceService> {
  using Service::Service;

  Result Join(UserID &request) { return {}; }
};

// ==== RPC infrastructure
// TODO to put the per-RPC options (traits?)

template <typename T> class Rpc {};

template <typename ClassType, typename RequestType, typename ResponseType>
class Rpc<ResponseType (ClassType::*)(RequestType &)> : public RpcBase {
public:
  using MethodType = ResponseType (ClassType::*)(RequestType &);

  Rpc(std::shared_ptr<Actor> actor, MethodType method, RequestType &request)
      : m_request{request}, m_method{method},
        m_actor{std::static_pointer_cast<ClassType>(actor)} {}

  void execute() override {
    if (auto actor = m_actor.lock()) {
      actor->post([ this, service = actor.get() ] {
        m_response = (*service.*m_method)(m_request);
      });
    }
  }

private:
  RequestType m_request;
  ResponseType m_response;
  MethodType m_method = nullptr;
  std::weak_ptr<ClassType> m_actor;
};

// === Generated by RPC compiler

RpcBase reify_rpc(ActorPool &pool, Request &request) {
  // NOTE(rcm): in C++17 types can be deduced from arguments
  switch (request.which) {
  case 1: // user request
  {
    auto uuid = request.user.target.user;
    auto user = pool.get_or_create_actor<UserService>(uuid);
    switch (request.user.which) {
    case 1: // auth
      return Rpc<decltype(&UserService::Auth)>{user, &UserService::Auth,
                                               request.user.auth};
    case 2: // get
      return Rpc<decltype(&UserService::Get)>{user, &UserService::Get,
                                              request.user.get};
    case 3: // ping
      return Rpc<decltype(&UserService::Ping)>{user, &UserService::Ping,
                                               request.user.ping};
    }
  } break;
  case 2: // space request
  {
    auto uuid = request.space.target.space;
    auto space = pool.get_or_create_actor<SpaceService>(uuid);
    switch (request.space.which) {
    case 1: // join
      return Rpc<decltype(&SpaceService::Join)>{space, &SpaceService::Join,
                                                request.space.join};
    }
  } break;
  }
  return {};
}

// ==== Run

int main() {
  Channel<Packet> from_device;
  Channel<Packet> from_server;

  std::thread server{[&] {
    Server server{from_server, from_device};
    Dispatcher dispatcher;

    Packet packet;
    for (;;) {
      if (server.recv(packet)) {
        dispatcher.handle(packet);
        // Response response;
        // response.which = 1;
        // response.user.which = 1;
        // response.user.auth = user.Auth(request.user.auth);

        // Packet packet;
        // packet.responses.push_back(response);
        // server.send(packet);
      }
      std::this_thread::sleep_for(100ms);
    }
  }};

  std::thread device{[&] {
    Device device{from_device, from_server};

    Request request;
    request.which = 1;
    request.user.which = 1;
    request.user.auth.password = "sekret";
    request.user.target.user = "bob";

    Packet packet;
    packet.requests.push_back(request);
    device.send(packet);

    for (;;) {
      if (device.recv(packet)) {
        auto &response = packet.responses.back();
        if (response.which == 1 && response.user.which == 1 &&
            response.user.auth.token == "guhjob") {
          std::cout << "device authenticated" << std::endl;
        }
      }
      std::this_thread::sleep_for(100ms);
    }
  }};
}
